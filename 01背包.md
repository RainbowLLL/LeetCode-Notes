Acwing 01背包


二维动态规划
f[i][j]只看前i个物品，总体积为j的情况下，总价值最大是多少

result = max{f[n][0~V]}

f[i][j]：

1. 不选第i个物品，f[i][j] = f[i-1][j]
2. 选第i个物品，f[i][j] = f[i-1][j-v[i]] + w[i]

f[i][j] = max{1,2}

f[0][0] = 0;

时间O(NV)


```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010;

int n,m;
int f[N];
int v[N],w[N];

int main()
{
    cin >> n >> m;
    for(int i = 1;i <= n; i ++ ) cin >> v[i] >> w[i];
    
    for(int i = 1; i<=n; i ++ )
        for(int j = m; j >= v[i]; j -- ) // 从后往前遍历，为了保证算f[j]时，f[j-v[i]]还没算过，它就是i-1时的状态
                f[j] = max(f[j], f[j-v[i]] + w[i]);

    cout << f[m] <<endl;
    // 为什么不需要遍历取最大
    /*
    初始化，由于f[j]都被初始化为0,所以f[j]的含义变为，当前体积小于等于0时的最大价值
    
    如果要求体积恰好为j，则只把f[0]初始化为0，其余初始化为负无穷
    f[0] = 0;
    f[i] = -INF;
    */
    return 0;
}
```
